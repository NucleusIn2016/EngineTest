#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def face_detect_extract(self, inputImgName, tId, extType):
    """
    Parameters:
     - inputImgName
     - tId
     - extType
    """
    pass

  def image_detect_extract(self, inputImgName, fromImgId):
    """
    Parameters:
     - inputImgName
     - fromImgId
    """
    pass

  def multip_feature_query(self, tMulFeatureExtPara):
    """
    Parameters:
     - tMulFeatureExtPara
    """
    pass

  def face_feature_verify(self, inputFace0, inputFace1):
    """
    Parameters:
     - inputFace0
     - inputFace1
    """
    pass

  def mulalg_feature_verify(self, inputFace0, inputFace1, type):
    """
    Parameters:
     - inputFace0
     - inputFace1
     - type
    """
    pass

  def face_feature_compare(self, faceType0, faceId0, faceType1, faceId1):
    """
    Parameters:
     - faceType0
     - faceId0
     - faceType1
     - faceId1
    """
    pass

  def task_surveillance_create(self, info):
    """
    Parameters:
     - info
    """
    pass

  def task_surveillance_terminate(self, taskId):
    """
    Parameters:
     - taskId
    """
    pass

  def task_snaper_create(self, sourceType, sourceId):
    """
    Parameters:
     - sourceType
     - sourceId
    """
    pass

  def task_snaper_terminate(self, sourceType, sourceId):
    """
    Parameters:
     - sourceType
     - sourceId
    """
    pass

  def iface_engin_ioctrl(self, type, para0, para1, para2, para3):
    """
    Parameters:
     - type
     - para0
     - para1
     - para2
     - para3
    """
    pass

  def multi_face_verify_url(self, listPaths):
    """
    Parameters:
     - listPaths
    """
    pass

  def multi_face_verify_bin(self, listImgDat):
    """
    Parameters:
     - listImgDat
    """
    pass

  def multi_face_compare_bin(self, imgdata1, imgdata2):
    """
    Parameters:
     - imgdata1
     - imgdata2
    """
    pass

  def multi_image_import(self, listImgInfo, type, srcType, srcId):
    """
    Parameters:
     - listImgInfo
     - type
     - srcType
     - srcId
    """
    pass

  def multi_image_import2(self, ImgData, type, srcType, srcId, attr):
    """
    Parameters:
     - ImgData
     - type
     - srcType
     - srcId
     - attr
    """
    pass

  def face_detect_rect(self, inputImgName, feceId):
    """
    **********************************************************************************
    inputImgName  ImgPath
    feceId
    return string json { 'Rect':{ 'bottom':403,'left':680,'right':774,'top':309}}
    *************************************************************************************

    Parameters:
     - inputImgName
     - feceId
    """
    pass

  def capture_on_demand(self, srcId):
    """
    Parameters:
     - srcId
    """
    pass

  def iface_merge_ctrl(self, inputJsonParam):
    """
    Parameters:
     - inputJsonParam
    """
    pass

  def iface_add_camera(self, dwCameraId, strIpcAdr, dwIpcPort, strIpcUsr, strIpcPwd, dwEngineId):
    """
    Parameters:
     - dwCameraId
     - strIpcAdr
     - dwIpcPort
     - strIpcUsr
     - strIpcPwd
     - dwEngineId
    """
    pass

  def query_prgress_rate(self, QueryType, ProgressId):
    """
    Parameters:
     - QueryType
     - ProgressId
    """
    pass

  def engine_update_status(self, status):
    """
    Parameters:
     - status
    """
    pass

  def server_info(self, info):
    """
    Parameters:
     - info
    """
    pass

  def if_image_detect_extract_url(self, inputImg, beDetAttr, beFeaExtra, algType):
    """
    Parameters:
     - inputImg
     - beDetAttr
     - beFeaExtra
     - algType
    """
    pass

  def if_image_detect_extract_bin(self, inputImg, beDetAttr, beFeaExtra, algType):
    """
    Parameters:
     - inputImg
     - beDetAttr
     - beFeaExtra
     - algType
    """
    pass

  def if_image_detect_extract_url_v2(self, inputImg, AttrEnList, beFeaExtra, algType):
    """
    Parameters:
     - inputImg
     - AttrEnList
     - beFeaExtra
     - algType
    """
    pass

  def if_image_detect_extract_bin_v2(self, inputImg, AttrEnList, beFeaExtra, algType):
    """
    Parameters:
     - inputImg
     - AttrEnList
     - beFeaExtra
     - algType
    """
    pass

  def if_mulalg_face_verify_url(self, inputFace0, inputFace1, algType):
    """
    Parameters:
     - inputFace0
     - inputFace1
     - algType
    """
    pass

  def if_mulalg_face_verify_bin(self, inputFace0, inputFace1, algType):
    """
    Parameters:
     - inputFace0
     - inputFace1
     - algType
    """
    pass

  def motion_live_detect_url(self, inputVideoFileName, inputMotionList):
    """
    Parameters:
     - inputVideoFileName
     - inputMotionList
    """
    pass

  def if_feature_compare(self, feature0, featureLen0, feature1, featureLen1, version):
    """
    Parameters:
     - feature0
     - featureLen0
     - feature1
     - featureLen1
     - version
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def face_detect_extract(self, inputImgName, tId, extType):
    """
    Parameters:
     - inputImgName
     - tId
     - extType
    """
    self.send_face_detect_extract(inputImgName, tId, extType)
    return self.recv_face_detect_extract()

  def send_face_detect_extract(self, inputImgName, tId, extType):
    self._oprot.writeMessageBegin('face_detect_extract', TMessageType.CALL, self._seqid)
    args = face_detect_extract_args()
    args.inputImgName = inputImgName
    args.tId = tId
    args.extType = extType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_face_detect_extract(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = face_detect_extract_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "face_detect_extract failed: unknown result")

  def image_detect_extract(self, inputImgName, fromImgId):
    """
    Parameters:
     - inputImgName
     - fromImgId
    """
    self.send_image_detect_extract(inputImgName, fromImgId)
    return self.recv_image_detect_extract()

  def send_image_detect_extract(self, inputImgName, fromImgId):
    self._oprot.writeMessageBegin('image_detect_extract', TMessageType.CALL, self._seqid)
    args = image_detect_extract_args()
    args.inputImgName = inputImgName
    args.fromImgId = fromImgId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_image_detect_extract(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = image_detect_extract_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "image_detect_extract failed: unknown result")

  def multip_feature_query(self, tMulFeatureExtPara):
    """
    Parameters:
     - tMulFeatureExtPara
    """
    self.send_multip_feature_query(tMulFeatureExtPara)
    return self.recv_multip_feature_query()

  def send_multip_feature_query(self, tMulFeatureExtPara):
    self._oprot.writeMessageBegin('multip_feature_query', TMessageType.CALL, self._seqid)
    args = multip_feature_query_args()
    args.tMulFeatureExtPara = tMulFeatureExtPara
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_multip_feature_query(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = multip_feature_query_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "multip_feature_query failed: unknown result")

  def face_feature_verify(self, inputFace0, inputFace1):
    """
    Parameters:
     - inputFace0
     - inputFace1
    """
    self.send_face_feature_verify(inputFace0, inputFace1)
    return self.recv_face_feature_verify()

  def send_face_feature_verify(self, inputFace0, inputFace1):
    self._oprot.writeMessageBegin('face_feature_verify', TMessageType.CALL, self._seqid)
    args = face_feature_verify_args()
    args.inputFace0 = inputFace0
    args.inputFace1 = inputFace1
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_face_feature_verify(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = face_feature_verify_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "face_feature_verify failed: unknown result")

  def mulalg_feature_verify(self, inputFace0, inputFace1, type):
    """
    Parameters:
     - inputFace0
     - inputFace1
     - type
    """
    self.send_mulalg_feature_verify(inputFace0, inputFace1, type)
    return self.recv_mulalg_feature_verify()

  def send_mulalg_feature_verify(self, inputFace0, inputFace1, type):
    self._oprot.writeMessageBegin('mulalg_feature_verify', TMessageType.CALL, self._seqid)
    args = mulalg_feature_verify_args()
    args.inputFace0 = inputFace0
    args.inputFace1 = inputFace1
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_mulalg_feature_verify(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = mulalg_feature_verify_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "mulalg_feature_verify failed: unknown result")

  def face_feature_compare(self, faceType0, faceId0, faceType1, faceId1):
    """
    Parameters:
     - faceType0
     - faceId0
     - faceType1
     - faceId1
    """
    self.send_face_feature_compare(faceType0, faceId0, faceType1, faceId1)
    return self.recv_face_feature_compare()

  def send_face_feature_compare(self, faceType0, faceId0, faceType1, faceId1):
    self._oprot.writeMessageBegin('face_feature_compare', TMessageType.CALL, self._seqid)
    args = face_feature_compare_args()
    args.faceType0 = faceType0
    args.faceId0 = faceId0
    args.faceType1 = faceType1
    args.faceId1 = faceId1
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_face_feature_compare(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = face_feature_compare_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "face_feature_compare failed: unknown result")

  def task_surveillance_create(self, info):
    """
    Parameters:
     - info
    """
    self.send_task_surveillance_create(info)
    return self.recv_task_surveillance_create()

  def send_task_surveillance_create(self, info):
    self._oprot.writeMessageBegin('task_surveillance_create', TMessageType.CALL, self._seqid)
    args = task_surveillance_create_args()
    args.info = info
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_task_surveillance_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = task_surveillance_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "task_surveillance_create failed: unknown result")

  def task_surveillance_terminate(self, taskId):
    """
    Parameters:
     - taskId
    """
    self.send_task_surveillance_terminate(taskId)
    return self.recv_task_surveillance_terminate()

  def send_task_surveillance_terminate(self, taskId):
    self._oprot.writeMessageBegin('task_surveillance_terminate', TMessageType.CALL, self._seqid)
    args = task_surveillance_terminate_args()
    args.taskId = taskId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_task_surveillance_terminate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = task_surveillance_terminate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "task_surveillance_terminate failed: unknown result")

  def task_snaper_create(self, sourceType, sourceId):
    """
    Parameters:
     - sourceType
     - sourceId
    """
    self.send_task_snaper_create(sourceType, sourceId)
    return self.recv_task_snaper_create()

  def send_task_snaper_create(self, sourceType, sourceId):
    self._oprot.writeMessageBegin('task_snaper_create', TMessageType.CALL, self._seqid)
    args = task_snaper_create_args()
    args.sourceType = sourceType
    args.sourceId = sourceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_task_snaper_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = task_snaper_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "task_snaper_create failed: unknown result")

  def task_snaper_terminate(self, sourceType, sourceId):
    """
    Parameters:
     - sourceType
     - sourceId
    """
    self.send_task_snaper_terminate(sourceType, sourceId)
    return self.recv_task_snaper_terminate()

  def send_task_snaper_terminate(self, sourceType, sourceId):
    self._oprot.writeMessageBegin('task_snaper_terminate', TMessageType.CALL, self._seqid)
    args = task_snaper_terminate_args()
    args.sourceType = sourceType
    args.sourceId = sourceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_task_snaper_terminate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = task_snaper_terminate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "task_snaper_terminate failed: unknown result")

  def iface_engin_ioctrl(self, type, para0, para1, para2, para3):
    """
    Parameters:
     - type
     - para0
     - para1
     - para2
     - para3
    """
    self.send_iface_engin_ioctrl(type, para0, para1, para2, para3)
    return self.recv_iface_engin_ioctrl()

  def send_iface_engin_ioctrl(self, type, para0, para1, para2, para3):
    self._oprot.writeMessageBegin('iface_engin_ioctrl', TMessageType.CALL, self._seqid)
    args = iface_engin_ioctrl_args()
    args.type = type
    args.para0 = para0
    args.para1 = para1
    args.para2 = para2
    args.para3 = para3
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_iface_engin_ioctrl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = iface_engin_ioctrl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "iface_engin_ioctrl failed: unknown result")

  def multi_face_verify_url(self, listPaths):
    """
    Parameters:
     - listPaths
    """
    self.send_multi_face_verify_url(listPaths)
    return self.recv_multi_face_verify_url()

  def send_multi_face_verify_url(self, listPaths):
    self._oprot.writeMessageBegin('multi_face_verify_url', TMessageType.CALL, self._seqid)
    args = multi_face_verify_url_args()
    args.listPaths = listPaths
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_multi_face_verify_url(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = multi_face_verify_url_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "multi_face_verify_url failed: unknown result")

  def multi_face_verify_bin(self, listImgDat):
    """
    Parameters:
     - listImgDat
    """
    self.send_multi_face_verify_bin(listImgDat)
    return self.recv_multi_face_verify_bin()

  def send_multi_face_verify_bin(self, listImgDat):
    self._oprot.writeMessageBegin('multi_face_verify_bin', TMessageType.CALL, self._seqid)
    args = multi_face_verify_bin_args()
    args.listImgDat = listImgDat
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_multi_face_verify_bin(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = multi_face_verify_bin_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "multi_face_verify_bin failed: unknown result")

  def multi_face_compare_bin(self, imgdata1, imgdata2):
    """
    Parameters:
     - imgdata1
     - imgdata2
    """
    self.send_multi_face_compare_bin(imgdata1, imgdata2)
    return self.recv_multi_face_compare_bin()

  def send_multi_face_compare_bin(self, imgdata1, imgdata2):
    self._oprot.writeMessageBegin('multi_face_compare_bin', TMessageType.CALL, self._seqid)
    args = multi_face_compare_bin_args()
    args.imgdata1 = imgdata1
    args.imgdata2 = imgdata2
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_multi_face_compare_bin(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = multi_face_compare_bin_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "multi_face_compare_bin failed: unknown result")

  def multi_image_import(self, listImgInfo, type, srcType, srcId):
    """
    Parameters:
     - listImgInfo
     - type
     - srcType
     - srcId
    """
    self.send_multi_image_import(listImgInfo, type, srcType, srcId)
    return self.recv_multi_image_import()

  def send_multi_image_import(self, listImgInfo, type, srcType, srcId):
    self._oprot.writeMessageBegin('multi_image_import', TMessageType.CALL, self._seqid)
    args = multi_image_import_args()
    args.listImgInfo = listImgInfo
    args.type = type
    args.srcType = srcType
    args.srcId = srcId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_multi_image_import(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = multi_image_import_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "multi_image_import failed: unknown result")

  def multi_image_import2(self, ImgData, type, srcType, srcId, attr):
    """
    Parameters:
     - ImgData
     - type
     - srcType
     - srcId
     - attr
    """
    self.send_multi_image_import2(ImgData, type, srcType, srcId, attr)
    return self.recv_multi_image_import2()

  def send_multi_image_import2(self, ImgData, type, srcType, srcId, attr):
    self._oprot.writeMessageBegin('multi_image_import2', TMessageType.CALL, self._seqid)
    args = multi_image_import2_args()
    args.ImgData = ImgData
    args.type = type
    args.srcType = srcType
    args.srcId = srcId
    args.attr = attr
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_multi_image_import2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = multi_image_import2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "multi_image_import2 failed: unknown result")

  def face_detect_rect(self, inputImgName, feceId):
    """
    **********************************************************************************
    inputImgName  ImgPath
    feceId
    return string json { 'Rect':{ 'bottom':403,'left':680,'right':774,'top':309}}
    *************************************************************************************

    Parameters:
     - inputImgName
     - feceId
    """
    self.send_face_detect_rect(inputImgName, feceId)
    return self.recv_face_detect_rect()

  def send_face_detect_rect(self, inputImgName, feceId):
    self._oprot.writeMessageBegin('face_detect_rect', TMessageType.CALL, self._seqid)
    args = face_detect_rect_args()
    args.inputImgName = inputImgName
    args.feceId = feceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_face_detect_rect(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = face_detect_rect_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "face_detect_rect failed: unknown result")

  def capture_on_demand(self, srcId):
    """
    Parameters:
     - srcId
    """
    self.send_capture_on_demand(srcId)
    return self.recv_capture_on_demand()

  def send_capture_on_demand(self, srcId):
    self._oprot.writeMessageBegin('capture_on_demand', TMessageType.CALL, self._seqid)
    args = capture_on_demand_args()
    args.srcId = srcId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_capture_on_demand(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = capture_on_demand_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "capture_on_demand failed: unknown result")

  def iface_merge_ctrl(self, inputJsonParam):
    """
    Parameters:
     - inputJsonParam
    """
    self.send_iface_merge_ctrl(inputJsonParam)
    return self.recv_iface_merge_ctrl()

  def send_iface_merge_ctrl(self, inputJsonParam):
    self._oprot.writeMessageBegin('iface_merge_ctrl', TMessageType.CALL, self._seqid)
    args = iface_merge_ctrl_args()
    args.inputJsonParam = inputJsonParam
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_iface_merge_ctrl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = iface_merge_ctrl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "iface_merge_ctrl failed: unknown result")

  def iface_add_camera(self, dwCameraId, strIpcAdr, dwIpcPort, strIpcUsr, strIpcPwd, dwEngineId):
    """
    Parameters:
     - dwCameraId
     - strIpcAdr
     - dwIpcPort
     - strIpcUsr
     - strIpcPwd
     - dwEngineId
    """
    self.send_iface_add_camera(dwCameraId, strIpcAdr, dwIpcPort, strIpcUsr, strIpcPwd, dwEngineId)
    return self.recv_iface_add_camera()

  def send_iface_add_camera(self, dwCameraId, strIpcAdr, dwIpcPort, strIpcUsr, strIpcPwd, dwEngineId):
    self._oprot.writeMessageBegin('iface_add_camera', TMessageType.CALL, self._seqid)
    args = iface_add_camera_args()
    args.dwCameraId = dwCameraId
    args.strIpcAdr = strIpcAdr
    args.dwIpcPort = dwIpcPort
    args.strIpcUsr = strIpcUsr
    args.strIpcPwd = strIpcPwd
    args.dwEngineId = dwEngineId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_iface_add_camera(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = iface_add_camera_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "iface_add_camera failed: unknown result")

  def query_prgress_rate(self, QueryType, ProgressId):
    """
    Parameters:
     - QueryType
     - ProgressId
    """
    self.send_query_prgress_rate(QueryType, ProgressId)
    return self.recv_query_prgress_rate()

  def send_query_prgress_rate(self, QueryType, ProgressId):
    self._oprot.writeMessageBegin('query_prgress_rate', TMessageType.CALL, self._seqid)
    args = query_prgress_rate_args()
    args.QueryType = QueryType
    args.ProgressId = ProgressId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_query_prgress_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = query_prgress_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "query_prgress_rate failed: unknown result")

  def engine_update_status(self, status):
    """
    Parameters:
     - status
    """
    self.send_engine_update_status(status)
    return self.recv_engine_update_status()

  def send_engine_update_status(self, status):
    self._oprot.writeMessageBegin('engine_update_status', TMessageType.CALL, self._seqid)
    args = engine_update_status_args()
    args.status = status
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_engine_update_status(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = engine_update_status_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "engine_update_status failed: unknown result")

  def server_info(self, info):
    """
    Parameters:
     - info
    """
    self.send_server_info(info)
    return self.recv_server_info()

  def send_server_info(self, info):
    self._oprot.writeMessageBegin('server_info', TMessageType.CALL, self._seqid)
    args = server_info_args()
    args.info = info
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_server_info(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = server_info_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "server_info failed: unknown result")

  def if_image_detect_extract_url(self, inputImg, beDetAttr, beFeaExtra, algType):
    """
    Parameters:
     - inputImg
     - beDetAttr
     - beFeaExtra
     - algType
    """
    self.send_if_image_detect_extract_url(inputImg, beDetAttr, beFeaExtra, algType)
    return self.recv_if_image_detect_extract_url()

  def send_if_image_detect_extract_url(self, inputImg, beDetAttr, beFeaExtra, algType):
    self._oprot.writeMessageBegin('if_image_detect_extract_url', TMessageType.CALL, self._seqid)
    args = if_image_detect_extract_url_args()
    args.inputImg = inputImg
    args.beDetAttr = beDetAttr
    args.beFeaExtra = beFeaExtra
    args.algType = algType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_if_image_detect_extract_url(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = if_image_detect_extract_url_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "if_image_detect_extract_url failed: unknown result")

  def if_image_detect_extract_bin(self, inputImg, beDetAttr, beFeaExtra, algType):
    """
    Parameters:
     - inputImg
     - beDetAttr
     - beFeaExtra
     - algType
    """
    self.send_if_image_detect_extract_bin(inputImg, beDetAttr, beFeaExtra, algType)
    return self.recv_if_image_detect_extract_bin()

  def send_if_image_detect_extract_bin(self, inputImg, beDetAttr, beFeaExtra, algType):
    self._oprot.writeMessageBegin('if_image_detect_extract_bin', TMessageType.CALL, self._seqid)
    args = if_image_detect_extract_bin_args()
    args.inputImg = inputImg
    args.beDetAttr = beDetAttr
    args.beFeaExtra = beFeaExtra
    args.algType = algType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_if_image_detect_extract_bin(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = if_image_detect_extract_bin_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "if_image_detect_extract_bin failed: unknown result")

  def if_image_detect_extract_url_v2(self, inputImg, AttrEnList, beFeaExtra, algType):
    """
    Parameters:
     - inputImg
     - AttrEnList
     - beFeaExtra
     - algType
    """
    self.send_if_image_detect_extract_url_v2(inputImg, AttrEnList, beFeaExtra, algType)
    return self.recv_if_image_detect_extract_url_v2()

  def send_if_image_detect_extract_url_v2(self, inputImg, AttrEnList, beFeaExtra, algType):
    self._oprot.writeMessageBegin('if_image_detect_extract_url_v2', TMessageType.CALL, self._seqid)
    args = if_image_detect_extract_url_v2_args()
    args.inputImg = inputImg
    args.AttrEnList = AttrEnList
    args.beFeaExtra = beFeaExtra
    args.algType = algType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_if_image_detect_extract_url_v2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = if_image_detect_extract_url_v2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "if_image_detect_extract_url_v2 failed: unknown result")

  def if_image_detect_extract_bin_v2(self, inputImg, AttrEnList, beFeaExtra, algType):
    """
    Parameters:
     - inputImg
     - AttrEnList
     - beFeaExtra
     - algType
    """
    self.send_if_image_detect_extract_bin_v2(inputImg, AttrEnList, beFeaExtra, algType)
    return self.recv_if_image_detect_extract_bin_v2()

  def send_if_image_detect_extract_bin_v2(self, inputImg, AttrEnList, beFeaExtra, algType):
    self._oprot.writeMessageBegin('if_image_detect_extract_bin_v2', TMessageType.CALL, self._seqid)
    args = if_image_detect_extract_bin_v2_args()
    args.inputImg = inputImg
    args.AttrEnList = AttrEnList
    args.beFeaExtra = beFeaExtra
    args.algType = algType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_if_image_detect_extract_bin_v2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = if_image_detect_extract_bin_v2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "if_image_detect_extract_bin_v2 failed: unknown result")

  def if_mulalg_face_verify_url(self, inputFace0, inputFace1, algType):
    """
    Parameters:
     - inputFace0
     - inputFace1
     - algType
    """
    self.send_if_mulalg_face_verify_url(inputFace0, inputFace1, algType)
    return self.recv_if_mulalg_face_verify_url()

  def send_if_mulalg_face_verify_url(self, inputFace0, inputFace1, algType):
    self._oprot.writeMessageBegin('if_mulalg_face_verify_url', TMessageType.CALL, self._seqid)
    args = if_mulalg_face_verify_url_args()
    args.inputFace0 = inputFace0
    args.inputFace1 = inputFace1
    args.algType = algType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_if_mulalg_face_verify_url(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = if_mulalg_face_verify_url_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "if_mulalg_face_verify_url failed: unknown result")

  def if_mulalg_face_verify_bin(self, inputFace0, inputFace1, algType):
    """
    Parameters:
     - inputFace0
     - inputFace1
     - algType
    """
    self.send_if_mulalg_face_verify_bin(inputFace0, inputFace1, algType)
    return self.recv_if_mulalg_face_verify_bin()

  def send_if_mulalg_face_verify_bin(self, inputFace0, inputFace1, algType):
    self._oprot.writeMessageBegin('if_mulalg_face_verify_bin', TMessageType.CALL, self._seqid)
    args = if_mulalg_face_verify_bin_args()
    args.inputFace0 = inputFace0
    args.inputFace1 = inputFace1
    args.algType = algType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_if_mulalg_face_verify_bin(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = if_mulalg_face_verify_bin_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "if_mulalg_face_verify_bin failed: unknown result")

  def motion_live_detect_url(self, inputVideoFileName, inputMotionList):
    """
    Parameters:
     - inputVideoFileName
     - inputMotionList
    """
    self.send_motion_live_detect_url(inputVideoFileName, inputMotionList)
    return self.recv_motion_live_detect_url()

  def send_motion_live_detect_url(self, inputVideoFileName, inputMotionList):
    self._oprot.writeMessageBegin('motion_live_detect_url', TMessageType.CALL, self._seqid)
    args = motion_live_detect_url_args()
    args.inputVideoFileName = inputVideoFileName
    args.inputMotionList = inputMotionList
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_motion_live_detect_url(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = motion_live_detect_url_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "motion_live_detect_url failed: unknown result")

  def if_feature_compare(self, feature0, featureLen0, feature1, featureLen1, version):
    """
    Parameters:
     - feature0
     - featureLen0
     - feature1
     - featureLen1
     - version
    """
    self.send_if_feature_compare(feature0, featureLen0, feature1, featureLen1, version)
    return self.recv_if_feature_compare()

  def send_if_feature_compare(self, feature0, featureLen0, feature1, featureLen1, version):
    self._oprot.writeMessageBegin('if_feature_compare', TMessageType.CALL, self._seqid)
    args = if_feature_compare_args()
    args.feature0 = feature0
    args.featureLen0 = featureLen0
    args.feature1 = feature1
    args.featureLen1 = featureLen1
    args.version = version
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_if_feature_compare(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = if_feature_compare_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "if_feature_compare failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["face_detect_extract"] = Processor.process_face_detect_extract
    self._processMap["image_detect_extract"] = Processor.process_image_detect_extract
    self._processMap["multip_feature_query"] = Processor.process_multip_feature_query
    self._processMap["face_feature_verify"] = Processor.process_face_feature_verify
    self._processMap["mulalg_feature_verify"] = Processor.process_mulalg_feature_verify
    self._processMap["face_feature_compare"] = Processor.process_face_feature_compare
    self._processMap["task_surveillance_create"] = Processor.process_task_surveillance_create
    self._processMap["task_surveillance_terminate"] = Processor.process_task_surveillance_terminate
    self._processMap["task_snaper_create"] = Processor.process_task_snaper_create
    self._processMap["task_snaper_terminate"] = Processor.process_task_snaper_terminate
    self._processMap["iface_engin_ioctrl"] = Processor.process_iface_engin_ioctrl
    self._processMap["multi_face_verify_url"] = Processor.process_multi_face_verify_url
    self._processMap["multi_face_verify_bin"] = Processor.process_multi_face_verify_bin
    self._processMap["multi_face_compare_bin"] = Processor.process_multi_face_compare_bin
    self._processMap["multi_image_import"] = Processor.process_multi_image_import
    self._processMap["multi_image_import2"] = Processor.process_multi_image_import2
    self._processMap["face_detect_rect"] = Processor.process_face_detect_rect
    self._processMap["capture_on_demand"] = Processor.process_capture_on_demand
    self._processMap["iface_merge_ctrl"] = Processor.process_iface_merge_ctrl
    self._processMap["iface_add_camera"] = Processor.process_iface_add_camera
    self._processMap["query_prgress_rate"] = Processor.process_query_prgress_rate
    self._processMap["engine_update_status"] = Processor.process_engine_update_status
    self._processMap["server_info"] = Processor.process_server_info
    self._processMap["if_image_detect_extract_url"] = Processor.process_if_image_detect_extract_url
    self._processMap["if_image_detect_extract_bin"] = Processor.process_if_image_detect_extract_bin
    self._processMap["if_image_detect_extract_url_v2"] = Processor.process_if_image_detect_extract_url_v2
    self._processMap["if_image_detect_extract_bin_v2"] = Processor.process_if_image_detect_extract_bin_v2
    self._processMap["if_mulalg_face_verify_url"] = Processor.process_if_mulalg_face_verify_url
    self._processMap["if_mulalg_face_verify_bin"] = Processor.process_if_mulalg_face_verify_bin
    self._processMap["motion_live_detect_url"] = Processor.process_motion_live_detect_url
    self._processMap["if_feature_compare"] = Processor.process_if_feature_compare

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_face_detect_extract(self, seqid, iprot, oprot):
    args = face_detect_extract_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = face_detect_extract_result()
    try:
      result.success = self._handler.face_detect_extract(args.inputImgName, args.tId, args.extType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("face_detect_extract", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_image_detect_extract(self, seqid, iprot, oprot):
    args = image_detect_extract_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = image_detect_extract_result()
    try:
      result.success = self._handler.image_detect_extract(args.inputImgName, args.fromImgId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("image_detect_extract", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_multip_feature_query(self, seqid, iprot, oprot):
    args = multip_feature_query_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = multip_feature_query_result()
    try:
      result.success = self._handler.multip_feature_query(args.tMulFeatureExtPara)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("multip_feature_query", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_face_feature_verify(self, seqid, iprot, oprot):
    args = face_feature_verify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = face_feature_verify_result()
    try:
      result.success = self._handler.face_feature_verify(args.inputFace0, args.inputFace1)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("face_feature_verify", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_mulalg_feature_verify(self, seqid, iprot, oprot):
    args = mulalg_feature_verify_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mulalg_feature_verify_result()
    try:
      result.success = self._handler.mulalg_feature_verify(args.inputFace0, args.inputFace1, args.type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("mulalg_feature_verify", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_face_feature_compare(self, seqid, iprot, oprot):
    args = face_feature_compare_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = face_feature_compare_result()
    try:
      result.success = self._handler.face_feature_compare(args.faceType0, args.faceId0, args.faceType1, args.faceId1)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("face_feature_compare", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_task_surveillance_create(self, seqid, iprot, oprot):
    args = task_surveillance_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = task_surveillance_create_result()
    try:
      result.success = self._handler.task_surveillance_create(args.info)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("task_surveillance_create", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_task_surveillance_terminate(self, seqid, iprot, oprot):
    args = task_surveillance_terminate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = task_surveillance_terminate_result()
    try:
      result.success = self._handler.task_surveillance_terminate(args.taskId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("task_surveillance_terminate", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_task_snaper_create(self, seqid, iprot, oprot):
    args = task_snaper_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = task_snaper_create_result()
    try:
      result.success = self._handler.task_snaper_create(args.sourceType, args.sourceId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("task_snaper_create", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_task_snaper_terminate(self, seqid, iprot, oprot):
    args = task_snaper_terminate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = task_snaper_terminate_result()
    try:
      result.success = self._handler.task_snaper_terminate(args.sourceType, args.sourceId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("task_snaper_terminate", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_iface_engin_ioctrl(self, seqid, iprot, oprot):
    args = iface_engin_ioctrl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = iface_engin_ioctrl_result()
    try:
      result.success = self._handler.iface_engin_ioctrl(args.type, args.para0, args.para1, args.para2, args.para3)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("iface_engin_ioctrl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_multi_face_verify_url(self, seqid, iprot, oprot):
    args = multi_face_verify_url_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = multi_face_verify_url_result()
    try:
      result.success = self._handler.multi_face_verify_url(args.listPaths)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("multi_face_verify_url", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_multi_face_verify_bin(self, seqid, iprot, oprot):
    args = multi_face_verify_bin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = multi_face_verify_bin_result()
    try:
      result.success = self._handler.multi_face_verify_bin(args.listImgDat)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("multi_face_verify_bin", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_multi_face_compare_bin(self, seqid, iprot, oprot):
    args = multi_face_compare_bin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = multi_face_compare_bin_result()
    try:
      result.success = self._handler.multi_face_compare_bin(args.imgdata1, args.imgdata2)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("multi_face_compare_bin", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_multi_image_import(self, seqid, iprot, oprot):
    args = multi_image_import_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = multi_image_import_result()
    try:
      result.success = self._handler.multi_image_import(args.listImgInfo, args.type, args.srcType, args.srcId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("multi_image_import", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_multi_image_import2(self, seqid, iprot, oprot):
    args = multi_image_import2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = multi_image_import2_result()
    try:
      result.success = self._handler.multi_image_import2(args.ImgData, args.type, args.srcType, args.srcId, args.attr)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("multi_image_import2", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_face_detect_rect(self, seqid, iprot, oprot):
    args = face_detect_rect_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = face_detect_rect_result()
    try:
      result.success = self._handler.face_detect_rect(args.inputImgName, args.feceId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("face_detect_rect", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_capture_on_demand(self, seqid, iprot, oprot):
    args = capture_on_demand_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = capture_on_demand_result()
    try:
      result.success = self._handler.capture_on_demand(args.srcId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("capture_on_demand", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_iface_merge_ctrl(self, seqid, iprot, oprot):
    args = iface_merge_ctrl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = iface_merge_ctrl_result()
    try:
      result.success = self._handler.iface_merge_ctrl(args.inputJsonParam)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("iface_merge_ctrl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_iface_add_camera(self, seqid, iprot, oprot):
    args = iface_add_camera_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = iface_add_camera_result()
    try:
      result.success = self._handler.iface_add_camera(args.dwCameraId, args.strIpcAdr, args.dwIpcPort, args.strIpcUsr, args.strIpcPwd, args.dwEngineId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("iface_add_camera", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_query_prgress_rate(self, seqid, iprot, oprot):
    args = query_prgress_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = query_prgress_rate_result()
    try:
      result.success = self._handler.query_prgress_rate(args.QueryType, args.ProgressId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("query_prgress_rate", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_engine_update_status(self, seqid, iprot, oprot):
    args = engine_update_status_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = engine_update_status_result()
    try:
      result.success = self._handler.engine_update_status(args.status)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("engine_update_status", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_server_info(self, seqid, iprot, oprot):
    args = server_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = server_info_result()
    try:
      result.success = self._handler.server_info(args.info)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("server_info", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_if_image_detect_extract_url(self, seqid, iprot, oprot):
    args = if_image_detect_extract_url_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = if_image_detect_extract_url_result()
    try:
      result.success = self._handler.if_image_detect_extract_url(args.inputImg, args.beDetAttr, args.beFeaExtra, args.algType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("if_image_detect_extract_url", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_if_image_detect_extract_bin(self, seqid, iprot, oprot):
    args = if_image_detect_extract_bin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = if_image_detect_extract_bin_result()
    try:
      result.success = self._handler.if_image_detect_extract_bin(args.inputImg, args.beDetAttr, args.beFeaExtra, args.algType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("if_image_detect_extract_bin", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_if_image_detect_extract_url_v2(self, seqid, iprot, oprot):
    args = if_image_detect_extract_url_v2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = if_image_detect_extract_url_v2_result()
    try:
      result.success = self._handler.if_image_detect_extract_url_v2(args.inputImg, args.AttrEnList, args.beFeaExtra, args.algType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("if_image_detect_extract_url_v2", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_if_image_detect_extract_bin_v2(self, seqid, iprot, oprot):
    args = if_image_detect_extract_bin_v2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = if_image_detect_extract_bin_v2_result()
    try:
      result.success = self._handler.if_image_detect_extract_bin_v2(args.inputImg, args.AttrEnList, args.beFeaExtra, args.algType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("if_image_detect_extract_bin_v2", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_if_mulalg_face_verify_url(self, seqid, iprot, oprot):
    args = if_mulalg_face_verify_url_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = if_mulalg_face_verify_url_result()
    try:
      result.success = self._handler.if_mulalg_face_verify_url(args.inputFace0, args.inputFace1, args.algType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("if_mulalg_face_verify_url", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_if_mulalg_face_verify_bin(self, seqid, iprot, oprot):
    args = if_mulalg_face_verify_bin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = if_mulalg_face_verify_bin_result()
    try:
      result.success = self._handler.if_mulalg_face_verify_bin(args.inputFace0, args.inputFace1, args.algType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("if_mulalg_face_verify_bin", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_motion_live_detect_url(self, seqid, iprot, oprot):
    args = motion_live_detect_url_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = motion_live_detect_url_result()
    try:
      result.success = self._handler.motion_live_detect_url(args.inputVideoFileName, args.inputMotionList)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("motion_live_detect_url", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_if_feature_compare(self, seqid, iprot, oprot):
    args = if_feature_compare_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = if_feature_compare_result()
    try:
      result.success = self._handler.if_feature_compare(args.feature0, args.featureLen0, args.feature1, args.featureLen1, args.version)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("if_feature_compare", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class face_detect_extract_args:
  """
  Attributes:
   - inputImgName
   - tId
   - extType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputImgName', None, None, ), # 1
    (2, TType.I64, 'tId', None, None, ), # 2
    (3, TType.I32, 'extType', None, None, ), # 3
  )

  def __init__(self, inputImgName=None, tId=None, extType=None,):
    self.inputImgName = inputImgName
    self.tId = tId
    self.extType = extType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputImgName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.tId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.extType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('face_detect_extract_args')
    if self.inputImgName is not None:
      oprot.writeFieldBegin('inputImgName', TType.STRING, 1)
      oprot.writeString(self.inputImgName)
      oprot.writeFieldEnd()
    if self.tId is not None:
      oprot.writeFieldBegin('tId', TType.I64, 2)
      oprot.writeI64(self.tId)
      oprot.writeFieldEnd()
    if self.extType is not None:
      oprot.writeFieldBegin('extType', TType.I32, 3)
      oprot.writeI32(self.extType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputImgName)
    value = (value * 31) ^ hash(self.tId)
    value = (value * 31) ^ hash(self.extType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class face_detect_extract_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(T_IF_FACERECT, T_IF_FACERECT.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = T_IF_FACERECT()
            _elem54.read(iprot)
            self.success.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('face_detect_extract_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter55 in self.success:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class image_detect_extract_args:
  """
  Attributes:
   - inputImgName
   - fromImgId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputImgName', None, None, ), # 1
    (2, TType.I64, 'fromImgId', None, None, ), # 2
  )

  def __init__(self, inputImgName=None, fromImgId=None,):
    self.inputImgName = inputImgName
    self.fromImgId = fromImgId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputImgName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.fromImgId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('image_detect_extract_args')
    if self.inputImgName is not None:
      oprot.writeFieldBegin('inputImgName', TType.STRING, 1)
      oprot.writeString(self.inputImgName)
      oprot.writeFieldEnd()
    if self.fromImgId is not None:
      oprot.writeFieldBegin('fromImgId', TType.I64, 2)
      oprot.writeI64(self.fromImgId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputImgName)
    value = (value * 31) ^ hash(self.fromImgId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class image_detect_extract_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(T_IF_FACERECT, T_IF_FACERECT.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = T_IF_FACERECT()
            _elem61.read(iprot)
            self.success.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('image_detect_extract_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter62 in self.success:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multip_feature_query_args:
  """
  Attributes:
   - tMulFeatureExtPara
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tMulFeatureExtPara', (T_MulAlgFeatureExtReq, T_MulAlgFeatureExtReq.thrift_spec), None, ), # 1
  )

  def __init__(self, tMulFeatureExtPara=None,):
    self.tMulFeatureExtPara = tMulFeatureExtPara

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tMulFeatureExtPara = T_MulAlgFeatureExtReq()
          self.tMulFeatureExtPara.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multip_feature_query_args')
    if self.tMulFeatureExtPara is not None:
      oprot.writeFieldBegin('tMulFeatureExtPara', TType.STRUCT, 1)
      self.tMulFeatureExtPara.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tMulFeatureExtPara)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multip_feature_query_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (T_MulAlgFeatureExtRsp, T_MulAlgFeatureExtRsp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = T_MulAlgFeatureExtRsp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multip_feature_query_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class face_feature_verify_args:
  """
  Attributes:
   - inputFace0
   - inputFace1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputFace0', None, None, ), # 1
    (2, TType.STRING, 'inputFace1', None, None, ), # 2
  )

  def __init__(self, inputFace0=None, inputFace1=None,):
    self.inputFace0 = inputFace0
    self.inputFace1 = inputFace1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputFace0 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.inputFace1 = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('face_feature_verify_args')
    if self.inputFace0 is not None:
      oprot.writeFieldBegin('inputFace0', TType.STRING, 1)
      oprot.writeString(self.inputFace0)
      oprot.writeFieldEnd()
    if self.inputFace1 is not None:
      oprot.writeFieldBegin('inputFace1', TType.STRING, 2)
      oprot.writeString(self.inputFace1)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputFace0)
    value = (value * 31) ^ hash(self.inputFace1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class face_feature_verify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('face_feature_verify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mulalg_feature_verify_args:
  """
  Attributes:
   - inputFace0
   - inputFace1
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputFace0', None, None, ), # 1
    (2, TType.STRING, 'inputFace1', None, None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
  )

  def __init__(self, inputFace0=None, inputFace1=None, type=None,):
    self.inputFace0 = inputFace0
    self.inputFace1 = inputFace1
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputFace0 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.inputFace1 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mulalg_feature_verify_args')
    if self.inputFace0 is not None:
      oprot.writeFieldBegin('inputFace0', TType.STRING, 1)
      oprot.writeString(self.inputFace0)
      oprot.writeFieldEnd()
    if self.inputFace1 is not None:
      oprot.writeFieldBegin('inputFace1', TType.STRING, 2)
      oprot.writeString(self.inputFace1)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputFace0)
    value = (value * 31) ^ hash(self.inputFace1)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mulalg_feature_verify_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mulalg_feature_verify_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class face_feature_compare_args:
  """
  Attributes:
   - faceType0
   - faceId0
   - faceType1
   - faceId1
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'faceType0', None, None, ), # 1
    (2, TType.I64, 'faceId0', None, None, ), # 2
    (3, TType.I32, 'faceType1', None, None, ), # 3
    (4, TType.I64, 'faceId1', None, None, ), # 4
  )

  def __init__(self, faceType0=None, faceId0=None, faceType1=None, faceId1=None,):
    self.faceType0 = faceType0
    self.faceId0 = faceId0
    self.faceType1 = faceType1
    self.faceId1 = faceId1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.faceType0 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.faceId0 = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.faceType1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.faceId1 = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('face_feature_compare_args')
    if self.faceType0 is not None:
      oprot.writeFieldBegin('faceType0', TType.I32, 1)
      oprot.writeI32(self.faceType0)
      oprot.writeFieldEnd()
    if self.faceId0 is not None:
      oprot.writeFieldBegin('faceId0', TType.I64, 2)
      oprot.writeI64(self.faceId0)
      oprot.writeFieldEnd()
    if self.faceType1 is not None:
      oprot.writeFieldBegin('faceType1', TType.I32, 3)
      oprot.writeI32(self.faceType1)
      oprot.writeFieldEnd()
    if self.faceId1 is not None:
      oprot.writeFieldBegin('faceId1', TType.I64, 4)
      oprot.writeI64(self.faceId1)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.faceType0)
    value = (value * 31) ^ hash(self.faceId0)
    value = (value * 31) ^ hash(self.faceType1)
    value = (value * 31) ^ hash(self.faceId1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class face_feature_compare_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('face_feature_compare_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class task_surveillance_create_args:
  """
  Attributes:
   - info
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'info', (T_IF_TASK_INFO, T_IF_TASK_INFO.thrift_spec), None, ), # 1
  )

  def __init__(self, info=None,):
    self.info = info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.info = T_IF_TASK_INFO()
          self.info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('task_surveillance_create_args')
    if self.info is not None:
      oprot.writeFieldBegin('info', TType.STRUCT, 1)
      self.info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class task_surveillance_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('task_surveillance_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class task_surveillance_terminate_args:
  """
  Attributes:
   - taskId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'taskId', None, None, ), # 1
  )

  def __init__(self, taskId=None,):
    self.taskId = taskId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.taskId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('task_surveillance_terminate_args')
    if self.taskId is not None:
      oprot.writeFieldBegin('taskId', TType.I64, 1)
      oprot.writeI64(self.taskId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.taskId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class task_surveillance_terminate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('task_surveillance_terminate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class task_snaper_create_args:
  """
  Attributes:
   - sourceType
   - sourceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sourceType', None, None, ), # 1
    (2, TType.I64, 'sourceId', None, None, ), # 2
  )

  def __init__(self, sourceType=None, sourceId=None,):
    self.sourceType = sourceType
    self.sourceId = sourceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sourceType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.sourceId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('task_snaper_create_args')
    if self.sourceType is not None:
      oprot.writeFieldBegin('sourceType', TType.I32, 1)
      oprot.writeI32(self.sourceType)
      oprot.writeFieldEnd()
    if self.sourceId is not None:
      oprot.writeFieldBegin('sourceId', TType.I64, 2)
      oprot.writeI64(self.sourceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sourceType)
    value = (value * 31) ^ hash(self.sourceId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class task_snaper_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('task_snaper_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class task_snaper_terminate_args:
  """
  Attributes:
   - sourceType
   - sourceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sourceType', None, None, ), # 1
    (2, TType.I64, 'sourceId', None, None, ), # 2
  )

  def __init__(self, sourceType=None, sourceId=None,):
    self.sourceType = sourceType
    self.sourceId = sourceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sourceType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.sourceId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('task_snaper_terminate_args')
    if self.sourceType is not None:
      oprot.writeFieldBegin('sourceType', TType.I32, 1)
      oprot.writeI32(self.sourceType)
      oprot.writeFieldEnd()
    if self.sourceId is not None:
      oprot.writeFieldBegin('sourceId', TType.I64, 2)
      oprot.writeI64(self.sourceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sourceType)
    value = (value * 31) ^ hash(self.sourceId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class task_snaper_terminate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('task_snaper_terminate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class iface_engin_ioctrl_args:
  """
  Attributes:
   - type
   - para0
   - para1
   - para2
   - para3
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I64, 'para0', None, 0, ), # 2
    (3, TType.I64, 'para1', None, 0, ), # 3
    (4, TType.I64, 'para2', None, 0, ), # 4
    (5, TType.I64, 'para3', None, 0, ), # 5
  )

  def __init__(self, type=None, para0=thrift_spec[2][4], para1=thrift_spec[3][4], para2=thrift_spec[4][4], para3=thrift_spec[5][4],):
    self.type = type
    self.para0 = para0
    self.para1 = para1
    self.para2 = para2
    self.para3 = para3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.para0 = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.para1 = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.para2 = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.para3 = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('iface_engin_ioctrl_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.para0 is not None:
      oprot.writeFieldBegin('para0', TType.I64, 2)
      oprot.writeI64(self.para0)
      oprot.writeFieldEnd()
    if self.para1 is not None:
      oprot.writeFieldBegin('para1', TType.I64, 3)
      oprot.writeI64(self.para1)
      oprot.writeFieldEnd()
    if self.para2 is not None:
      oprot.writeFieldBegin('para2', TType.I64, 4)
      oprot.writeI64(self.para2)
      oprot.writeFieldEnd()
    if self.para3 is not None:
      oprot.writeFieldBegin('para3', TType.I64, 5)
      oprot.writeI64(self.para3)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.para0)
    value = (value * 31) ^ hash(self.para1)
    value = (value * 31) ^ hash(self.para2)
    value = (value * 31) ^ hash(self.para3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class iface_engin_ioctrl_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('iface_engin_ioctrl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multi_face_verify_url_args:
  """
  Attributes:
   - listPaths
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'listPaths', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, listPaths=None,):
    self.listPaths = listPaths

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.listPaths = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = iprot.readString()
            self.listPaths.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multi_face_verify_url_args')
    if self.listPaths is not None:
      oprot.writeFieldBegin('listPaths', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.listPaths))
      for iter69 in self.listPaths:
        oprot.writeString(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.listPaths)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multi_face_verify_url_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multi_face_verify_url_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multi_face_verify_bin_args:
  """
  Attributes:
   - listImgDat
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'listImgDat', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, listImgDat=None,):
    self.listImgDat = listImgDat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.listImgDat = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = iprot.readString()
            self.listImgDat.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multi_face_verify_bin_args')
    if self.listImgDat is not None:
      oprot.writeFieldBegin('listImgDat', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.listImgDat))
      for iter76 in self.listImgDat:
        oprot.writeString(iter76)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.listImgDat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multi_face_verify_bin_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multi_face_verify_bin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multi_face_compare_bin_args:
  """
  Attributes:
   - imgdata1
   - imgdata2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'imgdata1', None, None, ), # 1
    (2, TType.STRING, 'imgdata2', None, None, ), # 2
  )

  def __init__(self, imgdata1=None, imgdata2=None,):
    self.imgdata1 = imgdata1
    self.imgdata2 = imgdata2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.imgdata1 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.imgdata2 = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multi_face_compare_bin_args')
    if self.imgdata1 is not None:
      oprot.writeFieldBegin('imgdata1', TType.STRING, 1)
      oprot.writeString(self.imgdata1)
      oprot.writeFieldEnd()
    if self.imgdata2 is not None:
      oprot.writeFieldBegin('imgdata2', TType.STRING, 2)
      oprot.writeString(self.imgdata2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.imgdata1)
    value = (value * 31) ^ hash(self.imgdata2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multi_face_compare_bin_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multi_face_compare_bin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multi_image_import_args:
  """
  Attributes:
   - listImgInfo
   - type
   - srcType
   - srcId
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'listImgInfo', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.I32, 'srcType', None, None, ), # 3
    (4, TType.I64, 'srcId', None, None, ), # 4
  )

  def __init__(self, listImgInfo=None, type=None, srcType=None, srcId=None,):
    self.listImgInfo = listImgInfo
    self.type = type
    self.srcType = srcType
    self.srcId = srcId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.listImgInfo = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readString()
            self.listImgInfo.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.srcType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.srcId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multi_image_import_args')
    if self.listImgInfo is not None:
      oprot.writeFieldBegin('listImgInfo', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.listImgInfo))
      for iter83 in self.listImgInfo:
        oprot.writeString(iter83)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.srcType is not None:
      oprot.writeFieldBegin('srcType', TType.I32, 3)
      oprot.writeI32(self.srcType)
      oprot.writeFieldEnd()
    if self.srcId is not None:
      oprot.writeFieldBegin('srcId', TType.I64, 4)
      oprot.writeI64(self.srcId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.listImgInfo)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.srcType)
    value = (value * 31) ^ hash(self.srcId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multi_image_import_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multi_image_import_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multi_image_import2_args:
  """
  Attributes:
   - ImgData
   - type
   - srcType
   - srcId
   - attr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ImgData', None, None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.I32, 'srcType', None, None, ), # 3
    (4, TType.I64, 'srcId', None, None, ), # 4
    (5, TType.LIST, 'attr', (TType.STRUCT,(T_IF_IMGATTR, T_IF_IMGATTR.thrift_spec)), None, ), # 5
  )

  def __init__(self, ImgData=None, type=None, srcType=None, srcId=None, attr=None,):
    self.ImgData = ImgData
    self.type = type
    self.srcType = srcType
    self.srcId = srcId
    self.attr = attr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ImgData = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.srcType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.srcId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.attr = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = T_IF_IMGATTR()
            _elem89.read(iprot)
            self.attr.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multi_image_import2_args')
    if self.ImgData is not None:
      oprot.writeFieldBegin('ImgData', TType.STRING, 1)
      oprot.writeString(self.ImgData)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.srcType is not None:
      oprot.writeFieldBegin('srcType', TType.I32, 3)
      oprot.writeI32(self.srcType)
      oprot.writeFieldEnd()
    if self.srcId is not None:
      oprot.writeFieldBegin('srcId', TType.I64, 4)
      oprot.writeI64(self.srcId)
      oprot.writeFieldEnd()
    if self.attr is not None:
      oprot.writeFieldBegin('attr', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.attr))
      for iter90 in self.attr:
        iter90.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ImgData)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.srcType)
    value = (value * 31) ^ hash(self.srcId)
    value = (value * 31) ^ hash(self.attr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class multi_image_import2_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('multi_image_import2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class face_detect_rect_args:
  """
  Attributes:
   - inputImgName
   - feceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputImgName', None, None, ), # 1
    (2, TType.I64, 'feceId', None, None, ), # 2
  )

  def __init__(self, inputImgName=None, feceId=None,):
    self.inputImgName = inputImgName
    self.feceId = feceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputImgName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.feceId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('face_detect_rect_args')
    if self.inputImgName is not None:
      oprot.writeFieldBegin('inputImgName', TType.STRING, 1)
      oprot.writeString(self.inputImgName)
      oprot.writeFieldEnd()
    if self.feceId is not None:
      oprot.writeFieldBegin('feceId', TType.I64, 2)
      oprot.writeI64(self.feceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputImgName)
    value = (value * 31) ^ hash(self.feceId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class face_detect_rect_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('face_detect_rect_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class capture_on_demand_args:
  """
  Attributes:
   - srcId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'srcId', None, None, ), # 1
  )

  def __init__(self, srcId=None,):
    self.srcId = srcId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.srcId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('capture_on_demand_args')
    if self.srcId is not None:
      oprot.writeFieldBegin('srcId', TType.I64, 1)
      oprot.writeI64(self.srcId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.srcId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class capture_on_demand_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (T_CapRstOndemand, T_CapRstOndemand.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = T_CapRstOndemand()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('capture_on_demand_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class iface_merge_ctrl_args:
  """
  Attributes:
   - inputJsonParam
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputJsonParam', None, None, ), # 1
  )

  def __init__(self, inputJsonParam=None,):
    self.inputJsonParam = inputJsonParam

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputJsonParam = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('iface_merge_ctrl_args')
    if self.inputJsonParam is not None:
      oprot.writeFieldBegin('inputJsonParam', TType.STRING, 1)
      oprot.writeString(self.inputJsonParam)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputJsonParam)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class iface_merge_ctrl_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('iface_merge_ctrl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class iface_add_camera_args:
  """
  Attributes:
   - dwCameraId
   - strIpcAdr
   - dwIpcPort
   - strIpcUsr
   - strIpcPwd
   - dwEngineId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'dwCameraId', None, None, ), # 1
    (2, TType.STRING, 'strIpcAdr', None, None, ), # 2
    (3, TType.I32, 'dwIpcPort', None, None, ), # 3
    (4, TType.STRING, 'strIpcUsr', None, None, ), # 4
    (5, TType.STRING, 'strIpcPwd', None, None, ), # 5
    (6, TType.I32, 'dwEngineId', None, None, ), # 6
  )

  def __init__(self, dwCameraId=None, strIpcAdr=None, dwIpcPort=None, strIpcUsr=None, strIpcPwd=None, dwEngineId=None,):
    self.dwCameraId = dwCameraId
    self.strIpcAdr = strIpcAdr
    self.dwIpcPort = dwIpcPort
    self.strIpcUsr = strIpcUsr
    self.strIpcPwd = strIpcPwd
    self.dwEngineId = dwEngineId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.dwCameraId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.strIpcAdr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.dwIpcPort = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.strIpcUsr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.strIpcPwd = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.dwEngineId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('iface_add_camera_args')
    if self.dwCameraId is not None:
      oprot.writeFieldBegin('dwCameraId', TType.I64, 1)
      oprot.writeI64(self.dwCameraId)
      oprot.writeFieldEnd()
    if self.strIpcAdr is not None:
      oprot.writeFieldBegin('strIpcAdr', TType.STRING, 2)
      oprot.writeString(self.strIpcAdr)
      oprot.writeFieldEnd()
    if self.dwIpcPort is not None:
      oprot.writeFieldBegin('dwIpcPort', TType.I32, 3)
      oprot.writeI32(self.dwIpcPort)
      oprot.writeFieldEnd()
    if self.strIpcUsr is not None:
      oprot.writeFieldBegin('strIpcUsr', TType.STRING, 4)
      oprot.writeString(self.strIpcUsr)
      oprot.writeFieldEnd()
    if self.strIpcPwd is not None:
      oprot.writeFieldBegin('strIpcPwd', TType.STRING, 5)
      oprot.writeString(self.strIpcPwd)
      oprot.writeFieldEnd()
    if self.dwEngineId is not None:
      oprot.writeFieldBegin('dwEngineId', TType.I32, 6)
      oprot.writeI32(self.dwEngineId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dwCameraId)
    value = (value * 31) ^ hash(self.strIpcAdr)
    value = (value * 31) ^ hash(self.dwIpcPort)
    value = (value * 31) ^ hash(self.strIpcUsr)
    value = (value * 31) ^ hash(self.strIpcPwd)
    value = (value * 31) ^ hash(self.dwEngineId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class iface_add_camera_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('iface_add_camera_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class query_prgress_rate_args:
  """
  Attributes:
   - QueryType
   - ProgressId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'QueryType', None, None, ), # 1
    (2, TType.I32, 'ProgressId', None, None, ), # 2
  )

  def __init__(self, QueryType=None, ProgressId=None,):
    self.QueryType = QueryType
    self.ProgressId = ProgressId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.QueryType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ProgressId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('query_prgress_rate_args')
    if self.QueryType is not None:
      oprot.writeFieldBegin('QueryType', TType.I32, 1)
      oprot.writeI32(self.QueryType)
      oprot.writeFieldEnd()
    if self.ProgressId is not None:
      oprot.writeFieldBegin('ProgressId', TType.I32, 2)
      oprot.writeI32(self.ProgressId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.QueryType)
    value = (value * 31) ^ hash(self.ProgressId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class query_prgress_rate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (T_ProgressQueryRst, T_ProgressQueryRst.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = T_ProgressQueryRst()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('query_prgress_rate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class engine_update_status_args:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'status', None, None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.status = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('engine_update_status_args')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRING, 1)
      oprot.writeString(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class engine_update_status_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('engine_update_status_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class server_info_args:
  """
  Attributes:
   - info
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'info', None, None, ), # 1
  )

  def __init__(self, info=None,):
    self.info = info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.info = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('server_info_args')
    if self.info is not None:
      oprot.writeFieldBegin('info', TType.STRING, 1)
      oprot.writeString(self.info)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class server_info_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('server_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_image_detect_extract_url_args:
  """
  Attributes:
   - inputImg
   - beDetAttr
   - beFeaExtra
   - algType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputImg', None, None, ), # 1
    (2, TType.I32, 'beDetAttr', None, 0, ), # 2
    (3, TType.I32, 'beFeaExtra', None, 0, ), # 3
    (4, TType.I32, 'algType', None, -1, ), # 4
  )

  def __init__(self, inputImg=None, beDetAttr=thrift_spec[2][4], beFeaExtra=thrift_spec[3][4], algType=thrift_spec[4][4],):
    self.inputImg = inputImg
    self.beDetAttr = beDetAttr
    self.beFeaExtra = beFeaExtra
    self.algType = algType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputImg = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.beDetAttr = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.beFeaExtra = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.algType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_image_detect_extract_url_args')
    if self.inputImg is not None:
      oprot.writeFieldBegin('inputImg', TType.STRING, 1)
      oprot.writeString(self.inputImg)
      oprot.writeFieldEnd()
    if self.beDetAttr is not None:
      oprot.writeFieldBegin('beDetAttr', TType.I32, 2)
      oprot.writeI32(self.beDetAttr)
      oprot.writeFieldEnd()
    if self.beFeaExtra is not None:
      oprot.writeFieldBegin('beFeaExtra', TType.I32, 3)
      oprot.writeI32(self.beFeaExtra)
      oprot.writeFieldEnd()
    if self.algType is not None:
      oprot.writeFieldBegin('algType', TType.I32, 4)
      oprot.writeI32(self.algType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputImg)
    value = (value * 31) ^ hash(self.beDetAttr)
    value = (value * 31) ^ hash(self.beFeaExtra)
    value = (value * 31) ^ hash(self.algType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_image_detect_extract_url_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (T_MulAttrDetectRstRsp, T_MulAttrDetectRstRsp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = T_MulAttrDetectRstRsp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_image_detect_extract_url_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_image_detect_extract_bin_args:
  """
  Attributes:
   - inputImg
   - beDetAttr
   - beFeaExtra
   - algType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputImg', None, None, ), # 1
    (2, TType.I32, 'beDetAttr', None, 0, ), # 2
    (3, TType.I32, 'beFeaExtra', None, 0, ), # 3
    (4, TType.I32, 'algType', None, -1, ), # 4
  )

  def __init__(self, inputImg=None, beDetAttr=thrift_spec[2][4], beFeaExtra=thrift_spec[3][4], algType=thrift_spec[4][4],):
    self.inputImg = inputImg
    self.beDetAttr = beDetAttr
    self.beFeaExtra = beFeaExtra
    self.algType = algType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputImg = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.beDetAttr = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.beFeaExtra = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.algType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_image_detect_extract_bin_args')
    if self.inputImg is not None:
      oprot.writeFieldBegin('inputImg', TType.STRING, 1)
      oprot.writeString(self.inputImg)
      oprot.writeFieldEnd()
    if self.beDetAttr is not None:
      oprot.writeFieldBegin('beDetAttr', TType.I32, 2)
      oprot.writeI32(self.beDetAttr)
      oprot.writeFieldEnd()
    if self.beFeaExtra is not None:
      oprot.writeFieldBegin('beFeaExtra', TType.I32, 3)
      oprot.writeI32(self.beFeaExtra)
      oprot.writeFieldEnd()
    if self.algType is not None:
      oprot.writeFieldBegin('algType', TType.I32, 4)
      oprot.writeI32(self.algType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputImg)
    value = (value * 31) ^ hash(self.beDetAttr)
    value = (value * 31) ^ hash(self.beFeaExtra)
    value = (value * 31) ^ hash(self.algType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_image_detect_extract_bin_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (T_MulAttrDetectRstRsp, T_MulAttrDetectRstRsp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = T_MulAttrDetectRstRsp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_image_detect_extract_bin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_image_detect_extract_url_v2_args:
  """
  Attributes:
   - inputImg
   - AttrEnList
   - beFeaExtra
   - algType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputImg', None, None, ), # 1
    (2, TType.LIST, 'AttrEnList', (TType.I32,None), None, ), # 2
    (3, TType.I32, 'beFeaExtra', None, 0, ), # 3
    (4, TType.I32, 'algType', None, -1, ), # 4
  )

  def __init__(self, inputImg=None, AttrEnList=None, beFeaExtra=thrift_spec[3][4], algType=thrift_spec[4][4],):
    self.inputImg = inputImg
    self.AttrEnList = AttrEnList
    self.beFeaExtra = beFeaExtra
    self.algType = algType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputImg = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.AttrEnList = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = iprot.readI32()
            self.AttrEnList.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.beFeaExtra = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.algType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_image_detect_extract_url_v2_args')
    if self.inputImg is not None:
      oprot.writeFieldBegin('inputImg', TType.STRING, 1)
      oprot.writeString(self.inputImg)
      oprot.writeFieldEnd()
    if self.AttrEnList is not None:
      oprot.writeFieldBegin('AttrEnList', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.AttrEnList))
      for iter97 in self.AttrEnList:
        oprot.writeI32(iter97)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.beFeaExtra is not None:
      oprot.writeFieldBegin('beFeaExtra', TType.I32, 3)
      oprot.writeI32(self.beFeaExtra)
      oprot.writeFieldEnd()
    if self.algType is not None:
      oprot.writeFieldBegin('algType', TType.I32, 4)
      oprot.writeI32(self.algType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputImg)
    value = (value * 31) ^ hash(self.AttrEnList)
    value = (value * 31) ^ hash(self.beFeaExtra)
    value = (value * 31) ^ hash(self.algType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_image_detect_extract_url_v2_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (T_MulAttrDetectRstRsp_v2, T_MulAttrDetectRstRsp_v2.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = T_MulAttrDetectRstRsp_v2()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_image_detect_extract_url_v2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_image_detect_extract_bin_v2_args:
  """
  Attributes:
   - inputImg
   - AttrEnList
   - beFeaExtra
   - algType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputImg', None, None, ), # 1
    (2, TType.LIST, 'AttrEnList', (TType.I32,None), None, ), # 2
    (3, TType.I32, 'beFeaExtra', None, 0, ), # 3
    (4, TType.I32, 'algType', None, -1, ), # 4
  )

  def __init__(self, inputImg=None, AttrEnList=None, beFeaExtra=thrift_spec[3][4], algType=thrift_spec[4][4],):
    self.inputImg = inputImg
    self.AttrEnList = AttrEnList
    self.beFeaExtra = beFeaExtra
    self.algType = algType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputImg = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.AttrEnList = []
          (_etype101, _size98) = iprot.readListBegin()
          for _i102 in xrange(_size98):
            _elem103 = iprot.readI32()
            self.AttrEnList.append(_elem103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.beFeaExtra = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.algType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_image_detect_extract_bin_v2_args')
    if self.inputImg is not None:
      oprot.writeFieldBegin('inputImg', TType.STRING, 1)
      oprot.writeString(self.inputImg)
      oprot.writeFieldEnd()
    if self.AttrEnList is not None:
      oprot.writeFieldBegin('AttrEnList', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.AttrEnList))
      for iter104 in self.AttrEnList:
        oprot.writeI32(iter104)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.beFeaExtra is not None:
      oprot.writeFieldBegin('beFeaExtra', TType.I32, 3)
      oprot.writeI32(self.beFeaExtra)
      oprot.writeFieldEnd()
    if self.algType is not None:
      oprot.writeFieldBegin('algType', TType.I32, 4)
      oprot.writeI32(self.algType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputImg)
    value = (value * 31) ^ hash(self.AttrEnList)
    value = (value * 31) ^ hash(self.beFeaExtra)
    value = (value * 31) ^ hash(self.algType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_image_detect_extract_bin_v2_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (T_MulAttrDetectRstRsp_v2, T_MulAttrDetectRstRsp_v2.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = T_MulAttrDetectRstRsp_v2()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_image_detect_extract_bin_v2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_mulalg_face_verify_url_args:
  """
  Attributes:
   - inputFace0
   - inputFace1
   - algType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputFace0', None, None, ), # 1
    (2, TType.STRING, 'inputFace1', None, None, ), # 2
    (3, TType.I32, 'algType', None, -1, ), # 3
  )

  def __init__(self, inputFace0=None, inputFace1=None, algType=thrift_spec[3][4],):
    self.inputFace0 = inputFace0
    self.inputFace1 = inputFace1
    self.algType = algType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputFace0 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.inputFace1 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.algType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_mulalg_face_verify_url_args')
    if self.inputFace0 is not None:
      oprot.writeFieldBegin('inputFace0', TType.STRING, 1)
      oprot.writeString(self.inputFace0)
      oprot.writeFieldEnd()
    if self.inputFace1 is not None:
      oprot.writeFieldBegin('inputFace1', TType.STRING, 2)
      oprot.writeString(self.inputFace1)
      oprot.writeFieldEnd()
    if self.algType is not None:
      oprot.writeFieldBegin('algType', TType.I32, 3)
      oprot.writeI32(self.algType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputFace0)
    value = (value * 31) ^ hash(self.inputFace1)
    value = (value * 31) ^ hash(self.algType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_mulalg_face_verify_url_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (T_FaceVerifyRstRsp, T_FaceVerifyRstRsp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = T_FaceVerifyRstRsp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_mulalg_face_verify_url_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_mulalg_face_verify_bin_args:
  """
  Attributes:
   - inputFace0
   - inputFace1
   - algType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputFace0', None, None, ), # 1
    (2, TType.STRING, 'inputFace1', None, None, ), # 2
    (3, TType.I32, 'algType', None, -1, ), # 3
  )

  def __init__(self, inputFace0=None, inputFace1=None, algType=thrift_spec[3][4],):
    self.inputFace0 = inputFace0
    self.inputFace1 = inputFace1
    self.algType = algType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputFace0 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.inputFace1 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.algType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_mulalg_face_verify_bin_args')
    if self.inputFace0 is not None:
      oprot.writeFieldBegin('inputFace0', TType.STRING, 1)
      oprot.writeString(self.inputFace0)
      oprot.writeFieldEnd()
    if self.inputFace1 is not None:
      oprot.writeFieldBegin('inputFace1', TType.STRING, 2)
      oprot.writeString(self.inputFace1)
      oprot.writeFieldEnd()
    if self.algType is not None:
      oprot.writeFieldBegin('algType', TType.I32, 3)
      oprot.writeI32(self.algType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputFace0)
    value = (value * 31) ^ hash(self.inputFace1)
    value = (value * 31) ^ hash(self.algType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_mulalg_face_verify_bin_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (T_FaceVerifyRstRsp, T_FaceVerifyRstRsp.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = T_FaceVerifyRstRsp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_mulalg_face_verify_bin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class motion_live_detect_url_args:
  """
  Attributes:
   - inputVideoFileName
   - inputMotionList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputVideoFileName', None, None, ), # 1
    (2, TType.LIST, 'inputMotionList', (TType.I32,None), None, ), # 2
  )

  def __init__(self, inputVideoFileName=None, inputMotionList=None,):
    self.inputVideoFileName = inputVideoFileName
    self.inputMotionList = inputMotionList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputVideoFileName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.inputMotionList = []
          (_etype108, _size105) = iprot.readListBegin()
          for _i109 in xrange(_size105):
            _elem110 = iprot.readI32()
            self.inputMotionList.append(_elem110)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('motion_live_detect_url_args')
    if self.inputVideoFileName is not None:
      oprot.writeFieldBegin('inputVideoFileName', TType.STRING, 1)
      oprot.writeString(self.inputVideoFileName)
      oprot.writeFieldEnd()
    if self.inputMotionList is not None:
      oprot.writeFieldBegin('inputMotionList', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.inputMotionList))
      for iter111 in self.inputMotionList:
        oprot.writeI32(iter111)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputVideoFileName)
    value = (value * 31) ^ hash(self.inputMotionList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class motion_live_detect_url_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (T_MotionLiveDetectRst, T_MotionLiveDetectRst.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = T_MotionLiveDetectRst()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('motion_live_detect_url_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_feature_compare_args:
  """
  Attributes:
   - feature0
   - featureLen0
   - feature1
   - featureLen1
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'feature0', None, None, ), # 1
    (2, TType.I32, 'featureLen0', None, None, ), # 2
    (3, TType.STRING, 'feature1', None, None, ), # 3
    (4, TType.I32, 'featureLen1', None, None, ), # 4
    (5, TType.I32, 'version', None, None, ), # 5
  )

  def __init__(self, feature0=None, featureLen0=None, feature1=None, featureLen1=None, version=None,):
    self.feature0 = feature0
    self.featureLen0 = featureLen0
    self.feature1 = feature1
    self.featureLen1 = featureLen1
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.feature0 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.featureLen0 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.feature1 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.featureLen1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.version = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_feature_compare_args')
    if self.feature0 is not None:
      oprot.writeFieldBegin('feature0', TType.STRING, 1)
      oprot.writeString(self.feature0)
      oprot.writeFieldEnd()
    if self.featureLen0 is not None:
      oprot.writeFieldBegin('featureLen0', TType.I32, 2)
      oprot.writeI32(self.featureLen0)
      oprot.writeFieldEnd()
    if self.feature1 is not None:
      oprot.writeFieldBegin('feature1', TType.STRING, 3)
      oprot.writeString(self.feature1)
      oprot.writeFieldEnd()
    if self.featureLen1 is not None:
      oprot.writeFieldBegin('featureLen1', TType.I32, 4)
      oprot.writeI32(self.featureLen1)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 5)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.feature0)
    value = (value * 31) ^ hash(self.featureLen0)
    value = (value * 31) ^ hash(self.feature1)
    value = (value * 31) ^ hash(self.featureLen1)
    value = (value * 31) ^ hash(self.version)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class if_feature_compare_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('if_feature_compare_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
